6 - https://github.com/Jean-xavierr/42Cub3d.git


ft_init_program(av, mlx);
    ft_init_struct_infomap(&info_map);(initialize to zeroz)
    ft_read_management(av[1], &info_map);
        ft_check_extension(s);
        ft_read_info(s, info_map);/ open map file 
            ft_get_info_map(line, info_map);
                ft_get_info_map_resolution(s, info_map)
                ft_get_texture_path_north_south(s, info_map)
                ft_get_texture_path_west_east_s(s, info_map)
                ft_get_color(s, info_map)
            ft_read_map(info_map, fd, line);// malloc & save to info_map->map;
        ft_parse_management(info_map, &len)
            ft_parse_info(info_map); checks resolution, color & texture
                ft_check_open_texture(info_map); checks texture files opeining
            ft_parse_map_line_updown(info_map)/checks upper & bottom walls
            ft_parse_map_line_between(info_map, len)
                ft_get_len_line(info_map, len, line)
                ft_check_line1(info_map, len, line)
                ft_check_line2(info_map, len, line)
            ft_check_map(info_map)//checks all 0,1,2,N,S,E&W 
                ft_get_pos_player(info_map, i, x)// sets player position.
                    info_map->player_x = x;
		            info_map->player_y = i;
		            info_map->player_start = info_map->map[i][x];
    ft_check_len_map(&info_map);
        info_map->len_x = len_max;
	    info_map->len_y = y;
        ft_malloc_new_map(info_map, y, len_max);malloc & fill new map with ones same length
            ft_fill_map(info_map, new_map, len_max);
	ft_get_sprite_nb(&info_map);// count number of sprites
    ft_management_program(&info_map, &mlx);
        ft_get_pos_sprite(map, &storage);
            storage->sprite[n].x = (double)x + 0.5;
			storage->sprite[n].y = (double)y + 0.5;
		ft_init1(&move, &player, &ray);
        	ft_init_struct_move(&move); // zeroz move.
        	ft_init_struct_player(&player);// zeroz player ** player->ms 0.07 & player->rot_s 0.06
        	ft_init_struct_ray(&ray);
        ft_fill_storage(&move, &ray, &storage);
			storage->move = move;
			storage->ray = ray;
        ft_init_storage(map, mlx, &player, &storage);
        ft_init_pos_player(&storage, &player);
        mlx_init()
        mlx_new_window(mlx->ptr, map->rx, map->ry, "Cub3d")
        ft_init_texture(&storage, texture, 64, 64)
        mlx_hook(mlx->win, KEYPRESS_EVENT, KEYPRESS_MASK, ft_keypress, &move);
        mlx_hook(mlx->win, KEYRELEASE_EVENT, KEYRELEASE_MASK, ft_keyrelease, &move);
        mlx_hook(mlx->win, 17, 0, ft_exit_prog, &storage);
        mlx_loop_hook(mlx->ptr, ft_expose, &storage);
        mlx_loop(mlx->ptr);




To rotate a vector, multiply it with the rotation matrix

[ cos(a) -sin(a) ]
[ sin(a)  cos(a) ]

FOV is 2 * atan(0.66/1.0)=66Â°


//cameraX is the x-coordinate on the camera plane that the current x-coordinate of the screen represents

cam_x = 2 * x / rx - 1 // x-coordinate in camera space
raydir_x = dir_x + plane_x * cam_x
raydir_y = dir_y + plane_y * cam_x

//mapX and mapY represent the current square of the map the ray is in

map_x = pos_x
map_y = pos_y 

//sideDistX and sideDistY are initially the distance the ray has to travel from its start position to the first x-side and the first y-side. Later in the code they will be incremented while steps are taken.


deltadist_x = fabs(1/raydir_x)
deltadist_y = fabs(1/raydir_y)

ft_calcul_step_init_sidedist
if (raydir_x < 0)
	{
		step_x = -1;
		sidedist_x = (pos_x - map_x)
		* deltadist_x;
	}
	else
	{
		step_x = 1;
		sidedist_x = (map_x + 1.0 - pos_x)
		* deltadist_x;
	}
	if (raydir_y < 0)
	{
		step_y = -1;
		sidedist_y = (pos_y - map_y)
		* deltadist_y;
	}
	else
	{
		step_y = 1;
		sidedist_y = (map_y + 1.0 - pos_y)
		* deltadist_y;
	}

    --------------
    ft_ddaalgo(t_ray *ray, t_storage *storage, int x)
{
	while (ray->hit == 0)
	{
		if (sidedist_x < sidedist_y)
		{
			sidedist_x += deltadist_x;
			map_x += step_x;
			side = 0;
		}
		else
		{
			sidedist_y += deltadist_y;
			map_y += step_y;
			side = 1;
		}
		if (map[map_y][map_x] == '1')
			hit = 1;
	}
	if (side == 0)
		perpwalldist = (map_x - ->pos_x + (1 - step_x) / 2) / raydir_x;
	else
		perpwalldist = (map_y - ->pos_y + (1 - step_y) / 2) / raydir_y;
	storage->zbuffer[x] = perpwalldist;
}


3125

sideDistX and sideDistY are initially the distance the ray has to travel from its start position to the first x-side and the first y-side. Later in the code they will be incremented while steps are taken.

deltaDistX and deltaDistY are the distance the ray has to travel to go from 1 x-side to the next x-side, or from 1 y-side to the next y-side



inv_det : inverse of the determinant of transformation

sideDistX and sideDistY get incremented with deltaDistX with every jump in their direction, and mapX and mapY get incremented with stepX and stepY respectively.





//keycode 53 = esc
//keycode 13 = w
//keycode 1 = s
//keycode 0 = a
//keycode 2 = d
//keycode 123 = left
//keycode 124 = right
//keycode 257 = shift
//keycode 18 = 1
//keycode 19 = 2


segfault 
- delete up to texture 
- delete up to false & Ceiling
- player move over berrel
- map..cub
- delete some of xpm file will segfault


habu-zua@lab3r7s7 6 % lldb  ./cub3D ./map/map.cub 
(lldb) target create "./cub3D"
Current executable set to '/Users/habu-zua/Desktop/test/6/cub3D' (x86_64).
(lldb) settings set -- target.run-args  "./map/map.cub"
(lldb) br set --file ft_cub3d.c -l 97
Breakpoint 1: where = cub3D`main + 101 at ft_cub3d.c:97:19, address = 0x0000000100004d95
(lldb) r